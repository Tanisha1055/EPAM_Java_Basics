When a Java program starts, the operating system creates a new JVM process, and the ClassLoader
Subsystem loads required classes using the Bootstrap, Platform, and Application ClassLoaders,
performing loading, linking (verification, preparation, resolution), and initialization. The JVM
then sets up its runtime memory areas, including the Heap (for objects), Stacks (for method calls
and local variables, one per thread), Metaspace (for class metadata), PC registers, and native
method stacks. As the program runs, each thread executes bytecode using the Execution Engine,
where frequently used code is optimized by the JIT compiler. When an object is created using new,
memory is allocated in the Young Generation of the heap, the object is initialized, and a reference
(implemented internally as a pointer) is stored on the stack. Over time, unreachable objects become
eligible for garbage collection, where the JVM identifies live objects starting from GC roots,
reclaims memory, and compacts or relocates objects depending on the collector strategy. In modern
JVMs (Java 21â€“25), garbage collection largely happens concurrently, meaning objects can be moved
between heap regions while application threads continue running, using colored pointers and load
barriers so references are automatically redirected to the objectâ€™s new location without stopping
the program. This allows the JVM to manage memory efficiently with extremely short pauses, while
ensuring objects are always seen in a safe and consistent state until they eventually become
unreachable and their memory is reclaimed.


ğŸ“– The Story of a Java Object (Inside the JVM Kingdom)

ğŸŒ Chapter 1: The JVM Kingdom Is Born

You type:

public class Main {
    public static void main(String[] args) {
        Student s = new Student("Tanisha");
    }
}


You press Run.

ğŸ‘‰ The OS says:

â€œOkay, Iâ€™ll create a new JVM process.â€

ğŸ—ï¸ What exactly is the JVM?

The Java Virtual Machine (JVM) is:

A runtime engine
That runs bytecode
And manages memory, threads, and garbage collection
Each Java program = one JVM process.

ğŸ§¾ Chapter 2: Class Loading â€“ The Librarian Enters

Before your object can exist, JVM says:
â€œFirst, I must understand what a Student is.â€

ğŸ“š ClassLoader Subsystem (Very Important)

There are 3 main ClassLoaders:

Bootstrap ClassLoader
Loads core classes
Example: Object, String, System
Comes from rt.jar (Java 8)
Comes from modules (Java 9+)

Extension / Platform ClassLoader
Loads Java platform classes

Example: java.sql, java.logging

Application ClassLoader
Loads your classes

Example: Student, Main

ğŸ”„ Class Loading Phases

For Student.class:
Loading â†’ .class file read into memory

Linking

Verification (bytecode safety)
Preparation (static variables memory)
Resolution (symbolic â†’ direct references)

Initialization

Static blocks executed

Static variables assigned

ğŸ“Œ Only after thisâ€¦ object creation is allowed.

ğŸ§  Chapter 3: JVM Memory Areas (The City Map)

Now the JVM creates its memory world:

ğŸ™ï¸ Runtime Data Areas
1ï¸âƒ£ Heap (Shared)

Where objects live

Managed by Garbage Collector

Divided into:

Young Generation
Old Generation

2ï¸âƒ£ Stack (Per Thread)

Method calls

Local variables

References to objects

3ï¸âƒ£ Method Area

Class metadata

Method info

Static variables

âš ï¸ Java 8 change:

Method Area â†’ Metaspace

Moves outside heap

4ï¸âƒ£ PC Register

Keeps track of current instruction

5ï¸âƒ£ Native Method Stack

For JNI (C/C++ code)

ğŸ‘¶ Chapter 4: Object Birth â€“ new Student("Tanisha")

Now comes the magical line:

Student s = new Student("Tanisha");

Step-by-step (Slow Motion ğŸ¢)
ğŸ§± Step 1: Memory Allocation

JVM checks Heap

Finds space in Young Generation â†’ Eden space

ğŸ§ª Step 2: Default Initialization

All instance variables set to default:

int â†’ 0

String â†’ null

ğŸ§© Step 3: Constructor Call

Constructor runs

"Tanisha" assigned to name

ğŸ§µ Step 4: Reference Stored

Variable s goes to Stack

Actual object lives in Heap

ğŸ“Œ Important:

Reference in Stack â†’ Object in Heap

ğŸŒ± Chapter 5: Young Generation Explained (GC Favorite Topic)
Young Generation has:

Eden
Survivor S0
Survivor S1

New object â†’ Eden

ğŸ§¹ Chapter 6: Garbage Collection Begins (Drama ğŸ­)
ğŸ§  When does GC run?

Eden is full

JVM says:

â€œTime to clean!â€

ğŸ”¥ Minor GC (Young GC)
What happens?

JVM pauses your app (Stop-The-World)

Finds reachable objects

Moves them:
Eden â†’ Survivor (S0 or S1)
Dead objects â†’ deleted

This is fast GC.

ğŸ‚ Object Aging & Promotion

Each object has an age counter.
Survives GC once â†’ age = 1
Survives again â†’ age = 2

When age â‰¥ threshold:
ğŸ‘‰ Object moves to Old Generation

This is called Promotion.

ğŸ§“ Chapter 7: Old Generation (Long-Living Objects)

Objects like:

Cache
Static references
Singletons

Live here.

ğŸ’¥ Major GC / Full GC (The Scary One)
Triggered when:

Old Gen is full
Memory pressure

What it does:

Cleans Old Gen
May clean Metaspace
Longer pause times

ğŸ“Œ Interview tip:

Minor GC â‰  Full GC

ğŸ•°ï¸ Chapter 8: GC Evolution (Java 8 â†’ 17 â†’ 25)

Now the historical part ğŸ“œ

ğŸŸ  Java 8 Era (Classic Times)
Default GC:

Parallel GC

Other GCs:

Serial GC

CMS (Concurrent Mark Sweep) âŒ deprecated later

G1 GC (introduced earlier, optional)

Problems:

Long pauses

Fragmentation (CMS)

Not great for large heaps

ğŸŸ¢ Java 17 Era (Modern JVM)
Default GC:

âœ… G1 GC

Why G1 is loved:

Heap divided into regions
Predictable pause times
Concurrent marking
Compacts memory

Also available:

ZGC (low-latency)

Shenandoah (RedHat)

ğŸ”µ Java 25 Era (Ultra Modern JVM ğŸš€)
Big Focus:

Low latency
Scalability
Cloud-native JVM

Key Players:

ZGC (Production-ready)

Pause time < 10 ms

Colored pointers
Region-based
Concurrent relocation

Generational ZGC

Young + Old separation (new!)
Best of both worlds

Virtual Threads (Project Loom)

Millions of threads

Less pressure on GC

ğŸ“Œ Java 25 GC mindset:

â€œGC should be almost invisible.â€

ğŸ§¬ Chapter 9: Death of an Object â˜ ï¸

An object becomes eligible for GC when:

No reference from:

Stack

Static fields

Other reachable objects

âŒ finalize()

Deprecated âŒ

Unreliable

Removed conceptually

âœ… Modern Cleanup

try-with-resources

AutoCloseable

Cleaner API

ğŸ§  Chapter 10: JVM Object Life Summary (Interview Gold âœ¨)

Object Life Cycle

Class Loaded

Memory Allocated (Heap)

Constructor Executed

Object Used

Object Becomes Unreachable

GC Reclaims Memory

ğŸ¯ One-Line Interview Punches

â€œHeap is managed by GC, Stack is not.â€

â€œReference lives in Stack, object lives in Heap.â€

â€œJava 8 â†’ Parallel GC, Java 17 â†’ G1 GC, Java 25 â†’ ZGC dominance.â€

â€œMinor GC cleans Young Gen, Major GC cleans Old Gen.â€

â€œMetaspace replaced PermGen.â€

If you want, next I can:

ğŸ¤ Turn this into interview answers

ğŸ–Šï¸ Draw memory diagrams

ğŸ§ª Explain GC algorithms internally (mark, sweep, compact)

ğŸ§  Compare G1 vs ZGC vs Shenandoah